Transacciones

Hern√°n Rondelli
lucifer.unix.cabj@gmail.com

Universidad de Ciencias Empresariales y Sociales

* bit.ly/uces-db2-trans

.image img/uces-db2-trans.png

* Transacciones ‚Äì Para qu√© sirven?

* Transacciones ‚Äì Para qu√© sirven?

- Acceso concurrente a los datos
- Resistencia a fallas

* Acceso concurrente (1)

*access*‚Üí*read,*modify,*write*

Supongamos, dos modificaciones simult√°neas:

Acceso A

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

Acceso B

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

Si le cliente ten√≠a $10000 en su cuenta, cu√°nto dinero tiene ahora?

* Acceso concurrente (2)

*access*‚Üí*read,*modify,*write*

Supongamos, dos accesos simult√°neos:

Acceso A

 insert into alquiler select * from reserva where fecha = now()::date;
 delete from reserva where fecha = now()::date;

Acceso B

 select count(*) from reserva;
 select count(*) from alquiler;

Observaci√≥n

 now()::date == current_date

* Resistencia a fallas

Estamos procesando los alquileres y las reservas‚Ä¶

 insert into alquiler select * from reserva where fecha = current_date;
 delete from reserva where fecha = current_date;

pero Edenor nos corta la luz justo antes del `delete`!!! üòø

* Transacci√≥n

_Es_una_secuencia_de_operaciones_SQL_que_se_tratan_como_una_unidad_

- Cada transacci√≥n se ejecuta aisladamente
- Todo √≥ nada: se ejecuta completamente, √≥ no se ejecuta nada

* ACID

* ACID

- Atomicity
- Consistency
- Isolation
- Durability

* Atomicity

*Todo*√≥*nada:* se ejecuta completamente, √≥ no se ejecuta nada

La transacci√≥n siempre termina en `commit` √≥ en `rollback`

- `commit` ‚Üí la transacci√≥n se complet√≥ exitosamente

- `rollback` ‚Üí undo de una transacci√≥n parcial

* Consistency

Una transacci√≥n *nunca* deja a la base de datos en un estado *inconsistente*

- Cuando una transacci√≥n comienza, la base de datos est√° en un estado consistente

- Cuando una transacci√≥n termina, se garantiza que la base de datos est√° en un estado consistente

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan concurrentemente
- Los resultados de una transacci√≥n deben ser los mismos que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ orden secuencial de todas las transacciones 

* Ejemplo de serializaci√≥n

T1

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

T2

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

‚úÖ  T1, T2 

‚úÖ  T2, T1 

* Durability

Todas operaciones sobre la base de datos *no*deben* cambiar despu√©s de que se complet√≥ exitosamente la transacci√≥n

* Isolation Levels

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan *concurrentemente*
- Los resultados de una transacci√≥n *deben*ser*los*mismos* que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ *orden*secuencial* de todas las transacciones 

‚úÖ  T1, T2, T3, T7, T10, T8, T9, T6, T4, T5

*Observaci√≥n:*es*v√°lido*s√≥lo*para*serializable*

* Isolation Levels (por transacci√≥n)

Weaker to Stronger:
1. `read`uncommitted`
2. `read`committed`
3. `repeatable`read`

‚ûñ Overhead
‚ûï Concurrency
‚ûñ Consistencia

Default:
4. `serializable`

‚ûï Overhead
‚ûñ Concurrency

* Dirty Read

Cuando una transacci√≥n lee un valor escrito por una transacci√≥n `uncommitted`

T1

 -- saldo ‚Üí 10000
 begin;
 update caja_de_ahorro set saldo = saldo + 5000 where n√∫mero_de_cuenta = 626;
 -- saldo ‚Üí 15000
 -- ac√° podemos tener un rollback
 commit;

T2 (`read`uncommitted`)

 begin;
 ‚Ä¶
 select saldo from caja_de_ahorro where n√∫mero_de_cuenta = 626;
 commit;

* read uncommitted

La transacci√≥n puede tener valores dirty reads

 begin;
 set transaction isolation level read uncommitted;
 /* operaciones */
 commit;

* read committed

La transacci√≥n *no* puede tener valores dirty reads _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update cambio set compra = 25.75 where moneda = 'Dolar';
 commit;

T2

 begin;
 set transaction isolation level read committed;
 select max(compra) from cambio where moneda = 'Dolar';
 ‚Ä¶
 select max(compra) from cambio where moneda = 'Dolar';
 commit;

* repeatable read

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update cambio set compra = 25.75 where moneda = 'Dolar';
 update cambio set venta = 25.95 where moneda = 'Dolar';
 commit;

T2

 begin;
 set transaction isolation level repeatable read;
 select avg(compra) from cambio;
 select avg(venta) from cambio;
 commit;

* repeatable read (phantom tuples)

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 insert into cambio ["compra y venta para varias monedas"];
 commit;

T2

 begin;
 set transaction isolation level repeatable read;
 select * from cambio;
 select avg(compra) from cambio;
 select max(compra) from cambio;
 commit;

* read only

 begin;
 set transaction read only;
 select * from materia;
 select avg(nota) from materia_aprobada where legajo = 626;
 select nombre, apellido from alumno order by apellido;
 commit;

# empty title
* 

.image img/questions.png
